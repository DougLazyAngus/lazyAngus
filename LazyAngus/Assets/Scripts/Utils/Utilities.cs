// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

public class Utilities
{
	public const string appImageURL = "http://pixabay.com/static/uploads/photo/2012/05/07/03/24/baby-47809_640.png";
	public const string appURL = "http://www.lazyangus.com/";

	public static float GetZAngle (Vector3 vector)
	{
		vector.z = 0;
		float angle = Vector3.Angle (Vector3.right, vector);
		if (vector.y < 0) {
			return -angle;
		} else {
			return angle;
		}
	}

	public static GameObject FindChildWithTag (GameObject gameObject, string tag)
	{
		for (int i = 0; i < gameObject.transform.childCount; i++) {
			Transform child = gameObject.transform.GetChild (i);
			if (child.gameObject.tag == tag) {
				return child.gameObject;
			}
		}
		return null;
	}

	public static T FindComponentInAncestor<T> (GameObject gameObject)
	{
		T component = gameObject.GetComponent<T> ();
		if (component != null) {
			return component;
		}
		Transform parent = gameObject.transform.parent;
		if (!parent || !parent.gameObject) {
			return default(T);
		}
		return FindComponentInAncestor<T> (parent.gameObject);
	}

	public static void ShuffleList<T> (ref List<T> list)
	{
		for (int i = 0; i < list.Count; i++) {
			T temp = list [i];
			int randomIndex = Random.Range (i, list.Count);
			list [i] = list [randomIndex];
			list [randomIndex] = temp;
		}
	}

	public static Color TrafficLightColorLerp (float fractionFinished)
	{
		fractionFinished = Mathf.Clamp (fractionFinished, 0f, 1f);
		if (fractionFinished < 0.5f) {
			return Color.Lerp (Color.green, Color.yellow, fractionFinished * 2f);
		} else {
			return Color.Lerp (Color.yellow, Color.red, fractionFinished * 2f - 1f);
		}
	}
	
	public static string GetShareTitleForScore (int score)
	{
		int highScore = PlayerStats.instance.GetHighScore ();
		if (highScore == score) {
			return "New High Score!";
		} else {
			return "New Score!";
		}
		
	}
	
	public static string GetShareMessageForScore (int score)
	{
		int highScore = PlayerStats.instance.GetHighScore ();
		if (highScore == score) {
			return "I got a new High Score of " + score + " in Lazy Angus!"; 
		} else {
			return "I scored " + score + " in Lazy Angus!"; 
		}
	}

	[System.Runtime.InteropServices.DllImport("__Internal")]
	extern static public bool CanLaunchURL (string url);

	/*
	[System.Runtime.InteropServices.DllImport("__Internal")]
	extern static public bool AuthenticateGameCenterHack();
	*/

	private static bool AppCanLaunchURL (string url)
	{
		if (Application.platform == RuntimePlatform.IPhonePlayer) {
			return CanLaunchURL (appURL);
		} else {
			return true;
		}
	}

	private static void LaunchAppOrWebOnIOS (string appURL, string webURL)
	{
		if (CanLaunchURL (appURL)) {
			Debug.Log ("Can open appURL");
			Application.OpenURL (appURL);
		} else {
			Debug.Log ("Can't open appURL");
			Application.OpenURL (webURL);
		}
	}

	public static IEnumerator LaunchAppOrWeb (string appURL, string webURL)
	{

		if (Application.platform == RuntimePlatform.IPhonePlayer) {
			LaunchAppOrWebOnIOS (appURL, webURL);
			yield return new WaitForSeconds (0.001f);
		} else {
			// FIXME(dbanks)
			// No good solution yet.
		}
	}

	public static void SpaceHorizontally (float containingWidth, 
	                                     GameObject[] objects, 
	                                     float yOffset, 
	                                     float yWiggle = 0f)
	{
		float canvasWidth = containingWidth; 
		
		float totalObjectWidth = 0f;
		
		foreach (GameObject go in objects) {
			totalObjectWidth += go.GetComponent<RectTransform> ().rect.width;
		}
		
		float leftoverSpace = canvasWidth - totalObjectWidth;
		float margin = leftoverSpace / (objects.Length + 1);
		
		float leftEdge = -canvasWidth / 2;
		float objectXOffset;

		float wiggle = 0f;
		if (margin <= 0f) {
			wiggle = yWiggle;
		}

		foreach (GameObject go in objects) {
			RectTransform rt = go.GetComponent<RectTransform> ();
			float objectWidth = rt.rect.width;

			leftEdge += margin;
			
			objectXOffset = leftEdge + objectWidth / 2;
			
			Vector2 position = new Vector2 (objectXOffset, yOffset + wiggle);
			wiggle = -wiggle;
			
			rt.anchoredPosition = position;
			leftEdge += objectWidth;
		}

	}

	public static float GetIOSVersion ()
	{
		if (Application.platform != RuntimePlatform.IPhonePlayer) {
			return -1;
		}
		string v = SystemInfo.operatingSystem;

		Debug.Log ("GetIOSVersion: v = " + v);

		string[] bits = v.Split (' ');
		string lastBit = bits [bits.Length - 1];
		return float.Parse (lastBit, 
		                   System.Globalization.CultureInfo.InvariantCulture);
	}

	static System.DateTime epoch = new System.DateTime (1970, 1, 1);

	public static float SecondsSinceEpoch ()
	{
		System.TimeSpan t = System.DateTime.UtcNow - epoch;
		return (float)t.TotalSeconds;	
	}

	public static float[] GetBlendingCoefficients (float t, int numPoints)
	{
		float[] retVal = new float [numPoints];

		float[] values = new float [numPoints];
		for (int i = 0; i < numPoints; i++) {
			values [i] = (float)i / (float)(numPoints - 1);
		}

		for (int i = 0; i < numPoints; i++) {
			float coefficient = 1f;
			for (int j = 0; j < numPoints; j++) {
				if (j != i) {
					coefficient *= (t - values [j]) / (values [i] - values [j]);
				}
			}
			retVal [i] = coefficient;
		}
		return retVal;
	}

	public static int ParseIntWithDefault (string text, int defaultValue)
	{
		int value;
		if (int.TryParse (text, out value)) {
			return value;
		} else {
			return defaultValue;
		}
	}

	public static void MakeFanWithAngleRange (ref Mesh mesh, 
	                                         float startAngle, 
	                                         float endAngle, 
	                                         float radius, 
	                                         int numTriangles)
	{
		float totalRange = endAngle - startAngle;
		
		float angleIncrementDeg = totalRange / numTriangles;
		
		Vector3[] vertices = new Vector3[numTriangles + 2];
		Vector2[] uvs = new Vector2[numTriangles + 2];

		vertices [0].x = 0f;
		vertices [0].y = 0f;
		vertices [0].z = 0f;
		
		uvs [0].x = 0f;
		uvs [0].y = 0f;

		float angle;
		for (int i = 0; i < numTriangles + 1; i++) {
			angle = startAngle + i * angleIncrementDeg;
			vertices [i + 1].y = Mathf.Sin (Mathf.Deg2Rad * angle) * radius;
			vertices [i + 1].x = Mathf.Cos (Mathf.Deg2Rad * angle) * radius;
			vertices [i + 1].z = 0f;

			uvs [i + 1].x = 1f;
			uvs [i + 1].y = (float)i / (float)numTriangles;
		}
		
		int [] triangles = new int[numTriangles * 3];
		for (int i = 0; i < numTriangles; i++) {
			triangles [i * 3] = 0;
			triangles [i * 3 + 1] = i + 2;
			triangles [i * 3 + 2] = i + 1;
		}



		mesh.vertices = vertices;
		mesh.triangles = triangles;
		mesh.uv = uvs;

		mesh.RecalculateNormals ();
	}

	public static string AddTextColor (string input, Color color)
	{
		return "<color=#" + color.ToHexStringRGB () + ">" + input + "</color>";
	}
	
	public static string AddFontSize (string input, int size)
	{
		return "<size=" + size + ">" + input + "</size>";
	}

	public static void LerpTransform (float timeFraction, 
	                                 Vector2 fromPosition, 
	                                 float fromAngle, 
	                                 float fromScale, 
	                                 Vector2 toPosition, 
	                                 float toAngle, 
	                                 float toScale, 
	                                 Transform t)
	{
		Vector2 position;
		float angle;
		float scale;
		if (timeFraction <= 0) {
			position = fromPosition;
			angle = fromAngle;
			scale = fromScale;
		} else if (timeFraction >= 1) {
			position = toPosition;
			angle = toAngle;
			scale = toScale;
		} else {
			position = 
				Vector2.Lerp (fromPosition, 
				              toPosition, 
				              timeFraction);
			angle = Mathf.Lerp (fromAngle, 
			                    toAngle, 
			                    timeFraction);
			scale = Mathf.Lerp (fromScale, 
			                    toScale, 
			                    timeFraction);
		}

		t.localPosition = position;
		t.localRotation = Quaternion.Euler (0, 0, angle);
		t.localScale = new Vector2 (scale, scale);
	}	
}



