// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;


public class Utilities
{
	public const string appImageURL = "http://pixabay.com/static/uploads/photo/2012/05/07/03/24/baby-47809_640.png";
	public const string appURL = "http://www.lazyangus.com/";

	public static float GetZAngle(Vector3 vector) {
		vector.z = 0;
		float angle = Vector3.Angle (Vector3.right, vector);
		if (vector.y < 0) {
			return -angle;
		} else {
			return angle;
		}
	} 

	public static GameObject FindChildWithTag(GameObject gameObject, string tag) {
		for(int i = 0; i < gameObject.transform.childCount; i++){
			Transform child = gameObject.transform.GetChild(i);
			if(child.gameObject.tag == tag){
				return child.gameObject;
			}
		}
		return null;
	}

	public static T FindComponentInAncestor<T>(GameObject gameObject) {
		T component = gameObject.GetComponent<T> ();
		if (component != null) {
			return component;
		}
		Transform parent = gameObject.transform.parent;
		if (!parent || !parent.gameObject) {
			return default(T);
		}
		return FindComponentInAncestor<T> (parent.gameObject);
	}

	public static void ShuffleList<T>(ref List<T> list) {
		for (int i = 0; i < list.Count; i++) {
			T temp = list [i];
			int randomIndex = Random.Range (i, list.Count);
			list [i] = list [randomIndex];
			list [randomIndex] = temp;
		}
	}

	public static Color TrafficLightColorLerp (float fractionFinished) {
		fractionFinished = Mathf.Clamp (fractionFinished, 0f, 1f);
		if (fractionFinished < 0.5f) {
			return Color.Lerp (Color.green, Color.yellow, fractionFinished * 2f);
		} else {
			return Color.Lerp (Color.yellow, Color.red, fractionFinished * 2f - 1f);
		}
	}
	
	public static string GetShareTitleForScore(int score) {
		int highScore = PlayerStats.instance.GetHighScore ();
		if (highScore == score) {
			return "New High Score!";
		} else {
			return "New Score!";
		}
		
	}
	
	public static string GetShareMessageForScore(int score) {
		int highScore = PlayerStats.instance.GetHighScore ();
		if (highScore == score) {
			return "I got a new High Score of " + score + " in Lazy Angus!"; 
		} else {
			return "I scored " + score + " in Lazy Angus!"; 
		}
	}

	[System.Runtime.InteropServices.DllImport("__Internal")]
	extern static public bool CanLaunchURL(string url);

	/*
	[System.Runtime.InteropServices.DllImport("__Internal")]
	extern static public bool AuthenticateGameCenterHack();
	*/

	private static bool AppCanLaunchURL(string url) {
		if (Application.platform == RuntimePlatform.IPhonePlayer) {
			return CanLaunchURL (appURL);
		} else {
			return true;
		}
	}

	private static void LaunchAppOrWebOnIOS(string appURL, string webURL) {
		if (CanLaunchURL (appURL)) {
			Debug.Log ("Can open appURL");
			Application.OpenURL (appURL);
		} else {
			Debug.Log ("Can't open appURL");
			Application.OpenURL (webURL);
		}
	}

	public static IEnumerator LaunchAppOrWeb (string appURL, string webURL) {

		if (Application.platform == RuntimePlatform.IPhonePlayer) {
			LaunchAppOrWebOnIOS(appURL, webURL);
			yield return new WaitForSeconds (0.001f);
		} else {
			// FIXME(dbanks)
			// No good solution yet.
		}
	}

	public static void SpaceHorizontally(float containingWidth, 
	                                     GameObject[] objects, 
	                                     float yOffset, 
	                                     float yWiggle = 0f) {
		float canvasWidth = containingWidth; 
		
		float totalObjectWidth = 0f;
		
		foreach (GameObject go in objects) {
			totalObjectWidth += go.GetComponent<RectTransform>().rect.width;
		}
		
		float leftoverSpace = canvasWidth - totalObjectWidth;
		float margin = leftoverSpace / (objects.Length + 1);
		
		float leftEdge = -canvasWidth / 2;
		float objectXOffset;

		float wiggle = 0f;
		if (margin <= 0f) {
			wiggle = yWiggle;
		}

		foreach (GameObject go in objects) {
			RectTransform rt = go.GetComponent<RectTransform>();
			float objectWidth = rt.rect.width;

			leftEdge += margin;
			
			objectXOffset = leftEdge + objectWidth/2;
			
			Vector2 position = new Vector2(objectXOffset, yOffset + wiggle);
			wiggle = -wiggle;
			
			rt.anchoredPosition = position;
			leftEdge += objectWidth;
		}

	}

	public static float GetIOSVersion() {
		if (Application.platform != RuntimePlatform.IPhonePlayer) {
			return -1;
		}
		string v = SystemInfo.operatingSystem;

		Debug.Log ("GetIOSVersion: v = " + v);

		string[] bits = v.Split (' ');
		string lastBit = bits [bits.Length - 1];
		return float.Parse (lastBit, 
		                   System.Globalization.CultureInfo.InvariantCulture);
	}


	static System.DateTime epoch = new System.DateTime(1970, 1, 1);

	public static float SecondsSinceEpoch() {
		System.TimeSpan t = System.DateTime.UtcNow - epoch;
		return (float)t.TotalSeconds;	
	}


	public static float[] GetBlendingCoefficients (float t, int numPoints) {
		float[] retVal = new float [numPoints];

		float[] values = new float [numPoints];
		for (int i = 0; i < numPoints; i++) {
			values[i] = (float)i/(float)(numPoints-1);
		}

		for (int i = 0; i < numPoints; i++) {
			float coefficient = 1f;
			for (int j = 0; j < numPoints; j++) {
				if (j != i) {
					coefficient *= (t - values[j])/(values[i] - values[j]);
				}
			}
			retVal[i] = coefficient;
		}
		return retVal;
	}
}



